-- VHDL Entity alien_game_lib.c5_t3_register_bank_to_serial_data.symbol
--
-- Created:
--          by - roope.UNKNOWN (ROOPE-PC)
--          at - 18:20:55 20.11.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.3 (Build 4)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY c5_t3_register_bank_to_serial_data IS
   PORT( 
      clk      : IN     std_logic;
      color    : IN     std_logic_vector (23 DOWNTO 0);
      rst      : IN     std_logic;
      rx_ready : IN     std_logic;
      bit_out  : OUT    std_logic;
      channel  : OUT    std_logic_vector (7 DOWNTO 0);
      do_tx    : OUT    std_logic;
      lat      : OUT    std_logic;
      x        : OUT    std_logic_vector (7 DOWNTO 0);
      y        : OUT    std_logic_vector (7 DOWNTO 0)
   );

-- Declarations

END c5_t3_register_bank_to_serial_data ;

--
-- VHDL Architecture alien_game_lib.c5_t3_register_bank_to_serial_data.fsm
--
-- Created:
--          by - keskiner.UNKNOWN (HTC219-707-SPC)
--          at - 10:38:19 28.11.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.3 (Build 4)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
 
ARCHITECTURE fsm OF c5_t3_register_bank_to_serial_data IS

   -- Architecture Declarations
   SIGNAL bit_counter : integer RANGE 23 DOWNTO 0;  
   SIGNAL x_counter : std_logic_vector(7 DOWNTO 0);  
   SIGNAL y_counter : std_logic_vector(7 DOWNTO 0);  

   TYPE STATE_TYPE IS (
      init,
      set_bit_out,
      write_tx,
      next_bit,
      shift_y,
      turn_off_channels,
      set_x_and_y,
      sleep_4k,
      toggle_lat,
      sleep_5k5,
      reset_y_counter,
      s5,
      shift_x,
      reset_bit_counter,
      reset_x_counter,
      s0
   );
 
   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

   -- Declare Wait State internal signals
   SIGNAL csm_timer : std_logic_vector(12 DOWNTO 0);
   SIGNAL csm_next_timer : std_logic_vector(12 DOWNTO 0);
   SIGNAL csm_timeout : std_logic;
   SIGNAL csm_to_sleep_4k : std_logic;
   SIGNAL csm_to_sleep_5k5 : std_logic;
   SIGNAL csm_to_s0 : std_logic;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clk,
      rst
   )
   -----------------------------------------------------------------
   BEGIN
      IF (rst = '0') THEN
         current_state <= init;
         csm_timer <= (OTHERS => '0');
         -- Default Reset Values
         bit_counter <= 23;
         x_counter <= "00000001";
         y_counter <= "00000001";
      ELSIF (clk'EVENT AND clk = '1') THEN
         current_state <= next_state;
         csm_timer <= csm_next_timer;

         -- Combined Actions
         CASE current_state IS
            WHEN init => 
               bit_counter <= 23;
            WHEN next_bit => 
               bit_counter <= bit_counter -1;
            WHEN shift_y => 
               y_counter <=  y_counter(6 downto 0) & '0';
            WHEN reset_y_counter => 
               y_counter <= "00000001";
            WHEN shift_x => 
               x_counter <=  x_counter(6 downto 0) & '0';
            WHEN reset_bit_counter => 
               bit_counter <= 23;
            WHEN reset_x_counter => 
               x_counter <= "00000001";
            WHEN OTHERS =>
               NULL;
         END CASE;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      bit_counter,
      csm_timeout,
      current_state,
      rx_ready,
      x_counter,
      y_counter
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default assignments to Wait State entry flags
      csm_to_sleep_4k <= '0';
      csm_to_sleep_5k5 <= '0';
      csm_to_s0 <= '0';
      CASE current_state IS
         WHEN init => 
            next_state <= set_x_and_y;
         WHEN set_bit_out => 
            IF (rx_ready = '1') THEN 
               next_state <= write_tx;
            ELSIF (rx_ready = '0') THEN 
               next_state <= set_bit_out;
            ELSE
               next_state <= set_bit_out;
            END IF;
         WHEN write_tx => 
            IF (bit_counter = 0) THEN 
               next_state <= shift_x;
            ELSIF (bit_counter /= 0) THEN 
               next_state <= s0;
               csm_to_s0 <= '1';
            ELSE
               next_state <= write_tx;
            END IF;
         WHEN next_bit => 
            next_state <= set_bit_out;
         WHEN shift_y => 
            next_state <= s5;
         WHEN turn_off_channels => 
            next_state <= sleep_4k;
            csm_to_sleep_4k <= '1';
         WHEN set_x_and_y => 
            next_state <= set_bit_out;
         WHEN sleep_4k => 
            IF (csm_timeout = '1') THEN 
               next_state <= toggle_lat;
            ELSE
               next_state <= sleep_4k;
            END IF;
         WHEN toggle_lat => 
            next_state <= sleep_5k5;
            csm_to_sleep_5k5 <= '1';
         WHEN sleep_5k5 => 
            IF (csm_timeout = '1') THEN 
               next_state <= shift_y;
            ELSE
               next_state <= sleep_5k5;
            END IF;
         WHEN reset_y_counter => 
            next_state <= init;
         WHEN s5 => 
            IF (y_counter /= "00000000") THEN 
               next_state <= init;
            ELSIF (y_counter = "00000000") THEN 
               next_state <= reset_y_counter;
            ELSE
               next_state <= s5;
            END IF;
         WHEN shift_x => 
            next_state <= reset_bit_counter;
         WHEN reset_bit_counter => 
            IF (x_counter = "00000000") THEN 
               next_state <= reset_x_counter;
            ELSIF (x_counter /= "00000000") THEN 
               next_state <= set_x_and_y;
            ELSE
               next_state <= reset_bit_counter;
            END IF;
         WHEN reset_x_counter => 
            next_state <= turn_off_channels;
         WHEN s0 => 
            IF (csm_timeout = '1') THEN 
               next_state <= next_bit;
            ELSE
               next_state <= s0;
            END IF;
         WHEN OTHERS =>
            next_state <= init;
      END CASE;
   END PROCESS nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : PROCESS ( 
      bit_counter,
      color,
      current_state,
      x_counter,
      y_counter
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default Assignment
      bit_out <= '0';
      do_tx <= '0';
      lat <= '0';

      -- Combined Actions
      CASE current_state IS
         WHEN set_bit_out => 
            bit_out <= color ( bit_counter );
         WHEN write_tx => 
            bit_out <= color ( bit_counter );
            do_tx <= '1' ;
         WHEN next_bit => 
            do_tx <= '0' ;
         WHEN turn_off_channels => 
            channel <= "00000000";
         WHEN set_x_and_y => 
            y <= y_counter ;
            x <= x_counter ;
         WHEN toggle_lat => 
            lat <= '1' ;
            channel <= y_counter ;
         WHEN s0 => 
            bit_out <= color ( bit_counter );
            do_tx <= '1' ;
         WHEN OTHERS =>
            NULL;
      END CASE;
   END PROCESS output_proc;
 
   -----------------------------------------------------------------
   csm_wait_combo_proc: PROCESS (
      csm_timer,
      csm_to_sleep_4k,
      csm_to_sleep_5k5,
      csm_to_s0
   )
   -----------------------------------------------------------------
   VARIABLE csm_temp_timeout : std_logic;
   BEGIN
      IF (unsigned(csm_timer) = 0) THEN
         csm_temp_timeout := '1';
      ELSE
         csm_temp_timeout := '0';
      END IF;

      IF (csm_to_sleep_4k = '1') THEN
         csm_next_timer <= "0111110011111"; -- no cycles(4000)-1=3999
      ELSIF (csm_to_sleep_5k5 = '1') THEN
         csm_next_timer <= "1010101111011"; -- no cycles(5500)-1=5499
      ELSIF (csm_to_s0 = '1') THEN
         csm_next_timer <= "0000000000001"; -- no cycles(2)-1=1
      ELSE
         IF (csm_temp_timeout = '1') THEN
            csm_next_timer <= (OTHERS=>'0');
         ELSE
            csm_next_timer <= unsigned(csm_timer) - '1';
         END IF;
      END IF;
      csm_timeout <= csm_temp_timeout;
   END PROCESS csm_wait_combo_proc;

END fsm;
